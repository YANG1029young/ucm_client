/***************************************************************************//**
 * @copyright Copyright (c) by Hinge-Tech R&D Center.
 * @file  logging.h
 * @brief Head file for declaring log API.
 * @author Rimon Chen  
 * @version 01.00.00
 * @date  2019-07-05 
 * @par Description declare the base of log API for user\n
 * @par Others 
 * @par Function List
 *      1.
 *    
 * @par History:
 *      Date | Author| Modification
 *      -|-|-
 *      2019-07-17 | Rimon Chen | add new style of comment |
 *      2019-07-05 | Rimon Chen | create build this moudle |
 *     
 ******************************************************************************/
#ifndef ARA_LOG_LOGGING_H__
#define ARA_LOG_LOGGING_H__

#include <cstring>
#include <type_traits>
#include "ara/log/common.h"

namespace ara 
{
namespace log 
{

 /* forward declare Logger class */
class Logger;

/*!
 *  @brief Represents a 8 bit binary data type .
 * 
 */
struct LogRawBuffer 
{
    const void* const buffer;   /*!<  data buffer   */
    uint16_t size; /*!<  allowed size of the back-end   */
};

/*!
 *  @brief Represents a 8 bit hexadecimal value data type .
 * 
 */
struct LogHex8
{
    uint8_t  value;   /*!< uint8 data value */
};

/*!
 *  @brief Represents a 16 bit hexadecimal value data type .
 * 
 */
struct LogHex16
{
    uint16_t value; /*!< uint16 data value */
};

/*!
 *  @brief Represents a 32 bit hexadecimal value data type .
 * 
 */
struct LogHex32 
{ 
    uint32_t value; /*!< uint32 data value */
};

/*!
 *  @brief Represents a 64 bit hexadecimal value data type .
 * 
 */
struct LogHex64 
{ 
    uint64_t value; /*!< uint64 data value */
};

/*!
 *  @brief Represents a 8 bit binary data type .
 * 
 */
struct LogBin8  
{ 
    uint8_t  value; /*!< uint8 data value */
};

/*!
 *  @brief Represents a 16 bit binary data type .
 * 
 */
struct LogBin16 
{ 
    uint16_t value; /*!< uint16 data value */
};

/*!
 *  @brief Represents a 32 bit binary data type .
 * 
 */
struct LogBin32 
{ 
    uint32_t value; /*!< uint32 data value */
};

/*!
 *  @brief Represents a 64 bit binary data type .
 * 
 */
struct LogBin64 
{ 
    uint64_t value; /*!< uint64 data value */
};

/*!
 *  @brief Initializes the logging framework for the application with given properties.
 *  
 *  @details In case the kFile flag is set in logMode, the directory path needs to
 *   be provided. The actual file name will be generated by the Logging
 *   framework.
 * 
 *  @param appId The ID of the Application
 *  @param appDescription Description of the Application
 *  @param appDefLogLevel The application’s default log level
 *  @param logMode The log mode(s) to be used, if the LogMode::kFile is specified, the param directoryPath can not be empty
 *  @param directoryPath The directory path for the file log mode
 * 
 *  @note The call to InitLogging shall be done as early as possible
 *   inside the program runnable (e.g. the main() function or some init
 *   function).
 *  
 *   Usage:
 *  @code{.cpp}
 *   int main(int argc, char* argv[])
 *   {
 *      InitLogging("ABCD", "This is the application known as ABCD",
 *      LogLevel::kVerbose, LogMode::kRemote);
 *   }
 *  @endcode
 */
void InitLogging(std::string appId,  
                std::string appDescription, 
                LogLevel appDefLogLevel, 
                LogMode logMode, 
                std::string directoryPath = "/opt/platform/log/var") noexcept;

/*! 
 *  @brief Create a logger context.
 *  
 *  @details You can construct a Logger by giving context id , context description and default log loevel.
 *
 *  @param ctxId the ID of logger context
 *  @param ctxDescription the ID of logger conext description
 *  @param ctxDefLogLevel the default log loevel
 * 
 *  @return Reference to the internal managed instance of a Logger object.
 *   Ownership stays within the Logging framework.
 */
Logger& CreateLogger(std::string ctxId, std::string ctxDescription, LogLevel ctxDefLogLevel=LogLevel::kWarn) noexcept;


/*! 
 *  @brief Conversion of a uint8 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into hexadecimal number system.
 * 
 *  @return LogHex8 type that has a built-in stream handler.
 * 
 *  @note Logs decimal numbers in hexadecimal format
 */
constexpr LogHex8  HexFormat(uint8_t value) noexcept
{ 
    return LogHex8{value};
}

/*! 
 *  @brief Conversion of a int8 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into hexadecimal number system.
 * 
 *  @return LogHex8 type that has a built-in stream handler.
 * 
 *  @note Logs decimal numbers in hexadecimal format. Negatives are represented in 2’s complement.
 */
constexpr LogHex8  HexFormat(int8_t value) noexcept 
{ 
    return LogHex8{static_cast<uint8_t>(value)}; 
}

/*! 
 *  @brief Conversion of a uint16 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into hexadecimal number system.
 * 
 *  @return LogHex16 type that has a built-in stream handler.
 * 
 *  @note Logs decimal numbers in hexadecimal format
 */
constexpr LogHex16 HexFormat(uint16_t value) noexcept 
{ 
    return LogHex16{value};
}

/*! 
 *  @brief Conversion of a int16 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into hexadecimal number system.
 * 
 *  @return LogHex16 type that has a built-in stream handler.
 * 
 *  @note Logs decimal numbers in hexadecimal format. Negatives are represented in 2’s complement.
 */
constexpr LogHex16  HexFormat(int16_t value) noexcept 
{
    return LogHex16{static_cast<uint16_t>(value)};
}

/*! 
 *  @brief Conversion of a uint32 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into hexadecimal number system.
 * 
 *  @return LogHex32 type that has a built-in stream handler.
 * 
 *  @note Logs decimal numbers in hexadecimal format
 */
constexpr LogHex32 HexFormat(uint32_t value) noexcept 
{
    return LogHex32{value};
}

/*! 
 *  @brief Conversion of a uint32 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into hexadecimal number system.
 * 
 *  @return LogHex32 type that has a built-in stream handler.
 * 
 *  @note Logs decimal numbers in hexadecimal format. Negatives are represented in 2’s complement.
 */
constexpr LogHex32  HexFormat(int32_t value) noexcept
{
    return LogHex32{static_cast<uint32_t>(value)};
}

/*! 
 *  @brief Conversion of a uint64 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into hexadecimal number system.
 * 
 *  @return LogHex64 type that has a built-in stream handler.
 * 
 *  @note Logs decimal numbers in hexadecimal format
 */
constexpr LogHex64 HexFormat(uint64_t value) noexcept
{
    return LogHex64{value};
}

/*! 
 *  @brief Conversion of a int64 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into hexadecimal number system.
 * 
 *  @return LogHex64 type that has a built-in stream handler.
 * 
 *  @note Logs decimal numbers in hexadecimal format. Negatives are represented in 2’s complement.
 */
constexpr LogHex64  HexFormat(int64_t value) noexcept
{
    return LogHex64{static_cast<uint64_t>(value)};
}

/*! 
 *  @brief Conversion of a uint8 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into a binary value.
 * 
 *  @return LogBin8 type that has a built-in stream handler
 * 
 *  @note Logs decimal numbers in binary format.
 */
constexpr LogBin8  BinFormat(uint8_t value) noexcept
{
    return LogBin8{value};
}


/*! 
 *  @brief Conversion of a int8 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into a binary value.
 * 
 *  @return LogBin8 type that has a built-in stream handler
 * 
 *  @note Logs decimal numbers in binary format.
 */
constexpr LogBin8  BinFormat(int8_t value) noexcept
{
    return LogBin8{static_cast<uint8_t>(value)};
}

/*! 
 *  @brief Conversion of a uint16 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into a binary value.
 * 
 *  @return LogBin16 type that has a built-in stream handler
 * 
 *  @note Logs decimal numbers in binary format.
 */
constexpr LogBin16 BinFormat(uint16_t value) noexcept
{
    return LogBin16{value};
}

/*! 
 *  @brief Conversion of a int16 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into a binary value.
 * 
 *  @return LogBin16 type that has a built-in stream handler
 * 
 *  @note Logs decimal numbers in binary format. Negatives are represented in 2’s complement.
 */
constexpr LogBin16  BinFormat(int16_t value) noexcept
{
    return LogBin16{static_cast<uint16_t>(value)};
}

/*! 
 *  @brief Conversion of a uint32 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into a binary value.
 * 
 *  @return LogBin32 type that has a built-in stream handler
 * 
 *  @note Logs decimal numbers in binary format.
 */
constexpr LogBin32 BinFormat(uint32_t value) noexcept
{
    return LogBin32{value};
}

/*! 
 *  @brief Conversion of a int32 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into a binary value.
 * 
 *  @return LogBin32 type that has a built-in stream handler
 * 
 *  @note Logs decimal numbers in binary format. Negatives are represented in 2’s complement.
 */
constexpr LogBin32 BinFormat(int32_t value) noexcept
{
    return LogBin32{static_cast<uint32_t>(value)};
}


/*! 
 *  @brief Conversion of a uint64 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into a binary value.
 * 
 *  @return LogBin64 type that has a built-in stream handler
 * 
 *  @note Logs decimal numbers in binary format.
 */
constexpr LogBin64 BinFormat(uint64_t value) noexcept
{
    return LogBin64{value};
}


/*! 
 *  @brief Conversion of a int64 into a hexadecimal value.
 * 
 *  @param value Decimal number to be converted into a binary value.
 * 
 *  @return LogBin64 type that has a built-in stream handler
 * 
 *  @note Logs decimal numbers in hexadecimal format. Negatives are represented in 2’s complement.
 */
constexpr LogBin64 BinFormat(int64_t value) noexcept 
{ 
    return LogBin64{static_cast<uint64_t>(value)}; 
}


/*! 
 *  @brief Logs raw binary data by providing a buffer.
 * 
 *  @tparam T The type of the contents of value.
 *  @param value the value to convert to raw data.
 * 
 *  @return LogRawBuffer type that has a built-in stream handler.
 * 
 *  @note T can take an arbitrary type, though it is not possible to specify a pointer as an argument. In this
 *   case there is no way to get the size of the buffer specified by the pointer. The maximum size of
 *   the provided data that can be processed depends on the underlying back-end implementation.
 */
template <typename T, typename std::enable_if<!std::is_pointer< T>::value, std::nullptr_t >::type = nullptr>
constexpr LogRawBuffer RawBuffer(const T& value) noexcept
{
    return LogRawBuffer{static_cast<const void*>(&value), sizeof(T)};
}

} /* namespace log */
} /* namespace ara */

#endif // ARA_LOG_LOGGING_H__
